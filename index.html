<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>模型可视化平台</title>
    <style>
      body {
        margin: 0;
        background-color: #f4f4f4; /* 更柔和的灰白色背景 */
        position: relative;
      }
      div {
        box-sizing: border-box;
      }
      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        display: block;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <canvas id="canvas"></canvas>
    <script defer>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const nodes = [];
      const connections = [];
      const numNodes = 40; // 结点的数量
      const maxDistance = 300; // 结点之间连接的最大距离
      const nodeSpawnProbability = 0.3; // 结点生成的概率
      const mouseAttractionRadius = 100; // 鼠标指针的吸引半径
      const mouseAttractionStrength = 0.03; // 鼠标指针的吸引力
      const gravity = 0.005; // 结点的重力

      let mousePosition = { x: -1000, y: -1000 };

      class Node {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 10; // 结点的半径
          this.speedX = (Math.random() - 0.5) * 2; // 结点的初始水平速度
          this.speedY = Math.random() * 2; // 结点的初始下落速度
          this.originalX = x;
          this.originalY = y;
        }

        update() {
          const dx = this.originalX - this.x;
          const dy = this.originalY - this.y;
          this.x += dx * 0.01; // 向原始位置靠拢
          this.y += dy * 0.01; // 向原始位置靠拢

          // 鼠标指针的吸引力
          const distanceToMouse = calculateDistance(this, mousePosition);
          if (distanceToMouse < mouseAttractionRadius) {
            const attractionForce =
              (mouseAttractionRadius - distanceToMouse) *
              mouseAttractionStrength;
            const angle = Math.atan2(
              mousePosition.y - this.y,
              mousePosition.x - this.x
            );
            this.x += Math.cos(angle) * attractionForce;
            this.y += Math.sin(angle) * attractionForce;
          }

          // 应用重力
          this.speedY += gravity;

          // 更新位置
          this.x += this.speedX;
          this.y += this.speedY;

          // 边界检测
          if (
            this.x < 0 ||
            this.x > canvas.width ||
            this.y < 0 ||
            this.y > canvas.height
          ) {
            this.x = this.originalX;
            this.y = this.originalY;
            this.speedX = (Math.random() - 0.5) * 2; // 随机水平速度
            this.speedY = Math.random(); // 随机下落速度
          }
        }

        draw() {
          ctx.fillStyle = "rgba(120, 120, 120, 0.8)"; // 结点的颜色和不透明度（灰色）
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.closePath();
          ctx.fill();
        }
      }

      class Connection {
        constructor(nodeA, nodeB) {
          this.nodeA = nodeA;
          this.nodeB = nodeB;
          this.alpha = 0; // 连接线的初始透明度
          this.speed = Math.random() * 0.02 + 0.01; // 连接线的动画速度
        }

        update() {
          this.alpha += this.speed;
          if (this.alpha > 1) {
            this.alpha = 1;
            this.speed *= -1;
          } else if (this.alpha < 0) {
            this.alpha = 0;
            this.speed *= -1;
          }
        }

        draw() {
          const { x: x1, y: y1 } = this.nodeA;
          const { x: x2, y: y2 } = this.nodeB;

          const distance = calculateDistance(this.nodeA, this.nodeB);
          if (
            distance < maxDistance &&
            Math.abs(this.nodeA.y - this.nodeB.y) < maxDistance
          ) {
            ctx.strokeStyle = `rgba(120, 120, 120, ${this.alpha})`; // 连接线的颜色和透明度（灰色）
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.closePath();
            ctx.stroke();
          }
        }
      }

      function calculateDistance(nodeA, nodeB) {
        const dx = nodeA.x - nodeB.x;
        const dy = nodeA.y - nodeB.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function init() {
        for (let i = 0; i < numNodes; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          nodes.push(new Node(x, y));
        }

        for (let i = 0; i < numNodes; i++) {
          const nodeA = nodes[i];
          for (let j = i + 1; j < numNodes; j++) {
            const nodeB = nodes[j];
            const distance = calculateDistance(nodeA, nodeB);
            if (
              distance < maxDistance &&
              Math.random() < nodeSpawnProbability
            ) {
              connections.push(new Connection(nodeA, nodeB));
            }
          }
        }
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const node of nodes) {
          node.update();
          node.draw();
        }

        for (const connection of connections) {
          connection.update();
          connection.draw();
        }

        requestAnimationFrame(animate);
      }

      function handleMouseMove(event) {
        mousePosition.x = event.clientX;
        mousePosition.y = event.clientY;
      }

      function handleMouseLeave() {
        mousePosition.x = -1000;
        mousePosition.y = -1000;
      }

      init();
      animate();

      // 监听鼠标移动事件
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseleave", handleMouseLeave);
    </script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
